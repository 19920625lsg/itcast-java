# 疯狂Java讲义
![封面](封面.jpg)

## 目录

### 第1章 Java语言概述与开发环境
+ 1.1 Java语言的发展简史
+ 1.2 Java的竞争对手及各自优势
+ 1.2.1 C＃简介和优势
+ 1.2.2 Ruby简介和优势
+ 1.2.3 Python简介和优势
+ 1.3 Java程序运行机制
+ 1.3.1 高级语言的运行机制
+ 1.3.2 Java程序的运行机制和JVM
+ 1.4 开发Java的准备
+ 1.4.1 下载和安装Java 8的JDK
    + 学生提问：不是说JVM是运行Java程序的虚拟机吗?那JRE和JVM的关系是怎样的呢?
    + 学生提问：为什么不安装公共JRE呢?
+ 1.4.2 设置PATH环境变量
    + 学生提问：为什么选择用户变量?用户变量与系统变量有什么区别?
+ 1.5 第一个Java程序
+ 1.5.1 编辑Java源代码
+ 1.5.2 编译Java程序
    + 学生提问：当编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序怎么不需要指定目标文件的文件名呢?
+ 1.5.3 运行Java程序
+ 1.5.4 根据CLASSPATH环境变量定位类
+ 1.6 Java程序的基本规则
+ 1.6.1 Java程序的组织形式
+ 1.6.2 Java源文件的命名规则
+ 1.6.3 初学者容易犯的错误
+ 1.7 垃圾回收机制
+ 1.8 何时开始使用IDE工具
  + 学生提问：我想学习Java编程，到底是学习Eclipse好，还是学习 NetBeans好呢?
+ 1.9 本章小结
+ 本章练习

### 第2章 理解面向对象
+ 2.1 面向对象
  + 2.1.1 结构化程序设计简介
  + 2.1.2 程序的三种基本结构
  + 2.1.3 面向对象程序设计简介
  + 2.1.4 面向对象的基本特征
+ 2.2 UML（统一建模语言）介绍
  + 2.2.1 用例图
  + 2.2.2 类图
  + 2.2.3 组件图
  + 2.2.4 部署图
  + 2.2.5 顺序图
  + 2.2.6 活动图
  + 2.2.7 状态机图
+ 2.3 Java的面向对象特征
  + 2.3.1 一切都是对象
  + 2.3.2 类和对象
+ 2.4 本章小结

### 第3章 数据类型和运算符
+ 3.1 注释
  + 3.1.1 单行注释和多行注释
  + 3.1.2 文档注释
    + 学生提问：API文档是什么?
    + 学生提问：为什么要学习查看 API文档的方法?
+ 3.2 标识符和关键字
  + 3.2.1 分隔符
  + 3.2.2 标识符规则
  + 3.2.3 Java关键字
+ 3.3 数据类型分类
  + 学生提问：什么是变量?变量有什么用?
+ 3.4 基本数据类型
  + 3.4.1 整型
  + 3.4.2 字符型
    + 学生提问：什么是字符集?
  + 3.4.3 浮点型
  + 3.4.4 数值中使用下画线分隔
  + 3.4.5 布尔型
+ 3.5 基本类型的类型转换
  + 3.5.1 自动类型转换
  + 3.5.2 强制类型转换
  + 3.5.3 表达式类型的自动提升
+ 3.6 直接量
  + 3.6.1 直接量的类型
  + 3.6.2 直接量的赋值
+ 3.7 运算符
  + 3.7.1 算术运算符
  + 3.7.2 赋值运算符
  + 3.7.3 位运算符
  + 3.7.4 扩展后的赋值运算符
  + 3.7.5 比较运算符
  + 3.7.6 逻辑运算符
  + 3.7.7 三目运算符
  + 3.7.8 运算符的结合性和优先级
+ 3.8 本章小结
+ 本章练习

### 第4章 流程控制与数组
+ 4.1 顺序结构
+ 4.2 分支结构
  + 4.2.1 if条件语句
  + 4.2.2 Java 7增强后的switch分支语句
+ 4.3 循环结构
  + 4.3.1 while循环语句
  + 4.3.2 do while循环语句
  + 4.3.3 for循环
  + 4.3.4 嵌套循环
+ 4.4 控制循环结构
  + 4.4.1 使用break结束循环
  + 4.4.2 使用continue忽略本次循环剩下语句
  + 4.4.3 使用return结束方法
+ 4.5 数组类型
  + 4.5.1 理解数组：数组也是一种类型
    + 学生提问：int[]是一种类型吗?怎么使用这种类型呢?
  + 4.5.2 定义数组
  + 4.5.3 数组的初始化
    + 学生提问：能不能只分配内存空间，不赋初始值呢?
  + 4.5.4 使用数组
    + 学生提问：为什么要我记住这些异常信息?
  + 4.5.5 foreach循环
+ 4.6 深入数组
  + 4.6.1 内存中的数组
    + 学生提问：为什么有栈内存和堆内存之分?
  + 4.6.2 基本类型数组的初始化
  + 4.6.3 引用类型数组的初始化
  + 4.6.4 没有多维数组
    + 学生提问：我是否可以让图4.13中灰色覆盖的数组元素再次指向另一个数组?这样不就可以扩展成三维数组，甚至扩展成更多的数组吗?
  + 4.6.5 Java 8增强的工具类：Arrays
  + 4.6.6 数组的应用举例
+ 4.7 本章小结
+ 本章练习

### 第5章 面向对象（上）
+ 5.1 类和对象
  + 5.1.1 定义类
    + 学生提问：构造器不是没有返回值吗?为什么不能用void声明呢?
  + 5.1.2 对象的产生和使用
  + 5.1.3 对象、引用和指针
  + 5.1.4 对象的this引用
+ 5.2 方法详解
  + 5.2.1 方法的所属性
  + 5.2.2 方法的参数传递机制
  + 5.2.3 形参个数可变的方法
  + 5.2.4 递归方法
  + 5.2.5 方法重载
    + 学生提问：为什么方法的返回值类型不能用于区分重载的方法?
+ 5.3 成员变量和局部变量
  + 5.3.1 成员变量和局部变量
  + 5.3.2 成员变量的初始化和内存中的运行机制
  + 5.3.3 局部变量的初始化和内存中的运行机制
  + 5.3.4 变量的使用规则
+ 5.4 隐藏和封装
  + 5.4.1 理解封装
  + 5.4.2 使用访问控制符
  + 5.4.3 package、import和import static
  + 5.4.4 Java的常用包
+ 5.5 深入构造器
  + 5.5.1 使用构造器执行初始化
    + 学生提问：构造器是创建 Java对象的途径，是不是说构造器完全负责创建Java对象?
  + 5.5.2 构造器重载
    + 学生提问：为什么要用this来调用另一个重载的构造器?我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗?
+ 5.6 类的继承
  + 5.6.1 继承的特点
  + 5.6.2 重写父类的方法
  + 5.6.3 super限定
  + 5.6.4 调用父类构造器
    + 学生提问：为什么我创建Java对象时从未感觉到java.lang.Object类的构造器被调用过?
+ 5.7 多态
  + 5.7.1 多态性
  + 5.7.2 引用变量的强制类型转换
  + 5.7.3 instanceof运算符
+ 5.8 继承与组合
  + 5.8.1 使用继承的注意点
  + 5.8.2 利用组合实现复用
    + 学生提问：使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大?
+ 5.9 初始化块
  + 5.9.1 使用初始化块
  + 5.9.2 初始化块和构造器
  + 5.9.3 静态初始化块
+ 5.10 本章小结
+ 本章练习

### 第6章 面向对象（下）
+ 6.1 Java 8增强的包装类
  + 学生提问：Java为什么要对这些数据进行缓存呢?
+ 6.2 处理对象
  + 6.2.1 打印对象和toString方法
  + 6.2.2==和equals方法
    + 学生提问：上面程序中判断obj是否为Person类的实例时，为何不用obj instanceof Person来判断呢?
+ 6.3 类成员
  + 6.3.1 理解类成员
  + 6.3.2 单例（Singleton）类
+ 6.4 final修饰符
  + 6.4.1 final成员变量
  + 6.4.2 final局部变量
  + 6.4.3 final修饰基本类型变量和引用类型变量的区别
  + 6.4.4 可执行“宏替换”的final变量
  + 6.4.5 final方法
  + 6.4.6 final类
  + 6.4.7 不可变类
  + 6.4.8 缓存实例的不可变类
+ 6.5 抽象类
  + 6.5.1 抽象方法和抽象类
  + 6.5.2 抽象类的作用
+ 6.6 Java 8改进的接口
  + 6.6.1 接口的概念
  + 6.6.2 Java 8中接口的定义
  + 6.6.3 接口的继承
  + 6.6.4 使用接口
  + 6.6.5 接口和抽象类
  + 6.6.6 面向接口编程
+ 6.7 内部类
  + 6.7.1 非静态内部类
    + 学生提问：非静态内部类对象和外部类对象的关系是怎样的?
  + 6.7.2 静态内部类
    + 学生提问：为什么静态内部类的实例方法也不能访问外部类的实例属性呢?
    + 学生提问：接口里是否能定义内部接口?
  + 6.7.3 使用内部类
    + 学生提问：既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部呢?
  + 6.7.4 局部内部类
  + 6.7.5 Java 8改进的匿名内部类
+ 6.8 Java 8新增的Lambda表达式
  + 6.8.1 Lambda表达式入门
  + 6.8.2 Lambda表达式与函数式接口
  + 6.8.3 方法引用与构造器引用
  + 6.8.4 Lambda表达式与匿名内部类的联系和区别
  + 6.8.5 使用Lambda表达式调用Arrays的类方法
+ 6.9 枚举类
  + 6.9.1 手动实现枚举类
  + 6.9.2 枚举类入门
  + 6.9.3 枚举类的成员变量、方法和构造器
  + 6.9.4 实现接口的枚举类
    + 学生提问：枚举类不是用final修饰了吗?怎么还能派生子类呢?
  + 6.9.5 包含抽象方法的枚举类
+ 6.10 对象与垃圾回收
  + 6.10.1 对象在内存中的状态
  + 6.10.2 强制垃圾回收
  + 6.10.3 finalize方法
  + 6.10.4 对象的软、弱和虚引用
+ 6.11 修饰符的适用范围
+ 6.12 使用JAR文件
  + 6.12.1 jar命令详解
  + 6.12.2 创建可执行的JAR包
  + 6.12.3 关于JAR包的技巧
+ 6.13 本章小结
+ 本章练习

### 第7章 Java基础类库
+ 7.1 与用户互动
  + 7.1.1 运行Java程序的参数
  + 7.1.2 使用Scanner获取键盘输入
+ 7.2 系统相关
  + 7.2.1 System类
  + 7.2.2 Runtime类
+ 7.3 常用类
  + 7.3.1 Object类
  + 7.3.2 Java 7新增的Objects类
  + 7.3.3 String、StringBuffer和StringBuilder类
  + 7.3.4 Math类
  + 7.3.5 Java 7的ThreadLocalRandom与Random
  + 7.3.6 BigDecimal类
+ 7.4 Java 8的日期、时间类
  + 7.4.1 Date类
  + 7.4.2 Calendar类
  + 7.4.3 Java 8新增的日期、时间包
+ 7.5 正则表达式
  + 7.5.1 创建正则表达式
  + 7.5.2 使用正则表达式
+ 7.6 国际化与格式化
  + 7.6.1 Java国际化的思路
  + 7.6.2 Java支持的国家和语言
  + 7.6.3 完成程序国际化
  + 7.6.4 使用MessageFormat处理包含占位符的字符串
  + 7.6.5 使用类文件代替资源文件
  + 7.6.6 使用NumberFormat格式化数字
  + 7.6.7 使用DateFormat格式化日期、时间
  + 7.6.8 使用SimpleDateFormat格式化日期
+ 7.7 Java 8新增的日期、时间格式器
  + 7.7.1 使用DateTimeFormatter完成格式化
  + 7.7.2 使用DateTimeFormatter解析字符串
+ 7.8 本章小结
+ 本章练习

### 第8章 Java集合
+ 8.1 Java集合概述
+ 8.2 Collection和Iterator接口
  + 8.2.1 使用Lambda表达式遍历集合
  + 8.2.2 使用Java 8增强的Iterator遍历集合元素
  + 8.2.3 使用Lambda表达式遍历Iterator
  + 8.2.4 使用foreach循环遍历集合元素
  + 8.2.5 使用Java 8新增的Predicate操作集合
  + 8.2.6 使用Java 8新增的Stream操作集合
+ 8.3 Set集合
  + 8.3.1 HashSet类
    + 学生提问：hashCode（）方法对于HashSet是不是十分重要?
  + 8.3.2 LinkedHashSet类
  + 8.3.3 TreeSet类
  + 8.3.4 EnumSet类
  + 8.3.5 各Set实现类的性能分析
+ 8.4 List集合
  + 8.4.1 Java 8改进的List接口和ListIterator接口
  + 8.4.2 ArrayList和Vector实现类
  + 8.4.3 固定长度的List
+ 8.5 Queue集合
  + 8.5.1 PriorityQueue实现类
  + 8.5.2 Deque接口与ArrayDeque实现类
  + 8.5.3 LinkedList实现类
  + 8.5.4 各种线性表的性能分析
+ 8.6 Java 8增强的Map集合
  + 8.6.1 Java 8为Map新增的方法
  + 8.6.2 Java 8改进的HashMap和Hashtable实现类
  + 8.6.3 LinkedHashMap实现类
  + 8.6.4 使用Properties读写属性文件
  + 8.6.5 SortedMap接口和TreeMap实现类
  + 8.6.6 WeakHashMap实现类
  + 8.6.7 IdentityHashMap实现类
  + 8.6.8 EnumMap实现类
  + 8.6.9 各Map实现类的性能分析
+ 8.7 HashSet和HashMap的性能选项
+ 8.8 操作集合的工具类：Collections
  + 8.8.1 排序操作
  + 8.8.2 查找、替换操作
  + 8.8.3 同步控制
  + 8.8.4 设置不可变集合
+ 8.9 烦琐的接口：Enumeration
+ 8.10 本章小结
+ 本章练习

### 第9章 泛型
+ 9.1 泛型入门
  + 9.1.1 编译时不检查类型的异常
  + 9.1.2 使用泛型
  + 9.1.3 Java 7泛型的“菱形”语法
+ 9.2 深入泛型
  + 9.2.1 定义泛型接口、类
  + 9.2.2 从泛型类派生子类
  + 9.2.3 并不存在泛型类
+ 9.3 类型通配符
  + 9.3.1 使用类型通配符
  + 9.3.2 设定类型通配符的上限
  + 9.3.3 设定类型形参的上限
+ 9.4 泛型方法
  + 9.4.1 定义泛型方法
  + 9.4.2 泛型方法和类型通配符的区别
  + 9.4.3 Java 7的“菱形”语法与泛型构造器
  + 9.4.4 设定通配符下限
  + 9.4.5 泛型方法与方法重载
  + 9.4.6 Java 8改进的类型推断
+ 9.5 擦除和转换
+ 9.6 泛型与数组
+ 9.7 本章小结

### 第10章 异常处理
+ 10.1 异常概述
+ 10.2 异常处理机制
  + 10.2.1 使用try...catch捕获异常
  + 10.2.2 异常类的继承体系
  + 10.2.3 Java 7提供的多异常捕获
  + 10.2.4 访问异常信息
  + 10.2.5 使用finally回收资源
  + 10.2.6 异常处理的嵌套
  + 10.2.7 Java 7的自动关闭资源的try语句
+ 10.3 Checked异常和Runtime异常体系
  + 10.3.1 使用throws声明抛出异常
+ 10.4 使用throw抛出异常
  + 10.4.1 抛出异常
  + 10.4.2 自定义异常类
  + 10.4.3 catch和throw同时使用
  + 10.4.4 Java 7增强的throw语句
  + 10.4.5 异常链
+ 10.5 Java的异常跟踪栈
+ 10.6 异常处理规则
  + 10.6.1 不要过度使用异常
  + 10.6.2 不要使用过于庞大的try块
  + 10.6.3 避免使用Catch All语句
  + 10.6.4 不要忽略捕获到的异常
+ 10.7 本章小结
+ 本章练习

### 第11章 AWT编程
+ 11.1 GUI（图形用户界面）和AWT
+ 11.2 AWT容器
+ 11.3 布局管理器
  + 11.3.1 FlowLayout布局管理器
  + 11.3.2 BorderLayout布局管理器
    + 学生提问：BorderLayout最多只能放置5个组件吗?那它也太不实用了吧?
  + 11.3.3 GridLayout布局管理器
  + 11.3.4 GridBagLayout布局管理器
  + 11.3.5 CardLayout布局管理器
  + 11.3.6 绝对定位
  + 11.3.7 BoxLayout布局管理器
    + 学生提问：图11.15和图11.16显示的所有按钮都紧挨在一起，如果希望像FlowLayout、GridLayout等布局管理器那样指定组的间距应该怎么办?
+ 11.4 AWT常用组件
  + 11.4.1 基本组件
  + 11.4.2 对话框（Dialog）
+ 11.5 事件处理
  + 11.5.1 Java事件模型的流程
  + 11.5.2 事件和事件监听器
  + 11.5.3 事件适配器
  + 11.5.4 使用内部类实现监听器
  + 11.5.5 使用外部类实现监听器
  + 11.5.6 类本身作为事件监听器类
  + 11.5.7 匿名内部类实现监听器
+ 11.6 AWT菜单
  + 11.6.1 菜单条、菜单和菜单项
  + 11.6.2 右键菜单
    + 学生提问：为什么即使我没有给多行文本域编写右键菜单，但当我在多行文本域上单击右键时也一样会弹出右键菜单?
+ 11.7 在AWT中绘图
  + 11.7.1 画图的实现原理
  + 11.7.2 使用Graphics类
+ 11.8 处理位图
  + 11.8.1 Image抽象类和BufferedImage实现类
  + 11.8.2 使用ImageIO输入/输出位图
+ 11.9 剪贴板
  + 11.9.1 数据传递的类和接口
  + 11.9.2 传递文本
  + 11.9.3 使用系统剪贴板传递图像
  + 11.9.4 使用本地剪贴板传递对象引用
  + 11.9.5 通过系统剪贴板传递Java对象
+ 11.10 拖放功能
  + 11.10.1 拖放目标
  + 11.10.2 拖放源
+ 11.11 本章小结
+ 本章练习

### 第12章 Swing编程
+ 12.1 Swing概述
+ 12.2 Swing基本组件的用法
  + 12.2.1 Java 7 的Swing组件层次
  + 12.2.2 AWT组件的Swing实现
    + 学生提问：为什么单击Swing多行文本域时不是弹出像AWT多行文本域中的右键菜单?
  + 12.2.3 为组件设置边框
  + 12.2.4 Swing组件的双缓冲和键盘驱动
  + 12.2.5 使用JToolBar创建工具条
  + 12.2.6 使用JFileChooser和Java 7增强的JColorChooser
  + 12.2.7 使用JOptionPane
+ 12.3 Swing中的特殊容器
  + 12.3.1 使用JSplitPane
  + 12.3.2 使用JTabbedPane
  + 12.3.3 使用JLayeredPane、JDesktopPane和JInternalFrame
+ 12.4 Swing简化的拖放功能
+ 12.5 Java 7新增的Swing功能
  + 12.5.1 使用JLayer装饰组件
  + 12.5.2 创建透明、不规则形状窗口
+ 12.6 使用JProgressBar、ProgressMonitor和BoundedRangeModel创建进度条
  + 12.6.1 创建进度条
  + 12.6.2 创建进度对话框
+ 12.7 使用JSlider和BoundedRangeModel创建滑动条
+ 12.8 使用JSpinner和SpinnerModel创建微调控制器
+ 12.9 使用JList、JComboBox创建列表框
  + 12.9.1 简单列表框
  + 12.9.2 不强制存储列表项的ListModel和ComboBoxModel
  + 12.9.3 强制存储列表项的DefaultListModel和DefaultComboBoxModel
    + 学生提问：为什么JComboBox提供了添加、删除列表项的方法?而JList没有提供添加、删除列表项的方法呢?
  + 12.9.4 使用ListCellRenderer改变列表项外观
+ 12.10 使用JTree和TreeModel创建树
  + 12.10.1 创建树
  + 12.10.2 拖动、编辑树节点
  + 12.10.3 监听节点事件
  + 12.10.4 使用DefaultTreeCellRenderer改变节点外观
  + 12.10.5 扩展DefaultTreeCellRenderer改变节点外观
  + 12.10.6 实现TreeCellRenderer改变节点外观
+ 12.11 使用JTable和TableModel创建表格
  + 12.11.1 创建表格
    + 学生提问：我们指定的表格数据、表格列标题都是Object类型的数组，JTable如何显示这些Object对象?
  + 12.11.2 TableModel和监听器
  + 12.11.3 TableColumnModel和监听器
  + 12.11.4 实现排序
  + 12.11.5 绘制单元格内容
  + 12.11.6 编辑单元格内容
+ 12.12 使用JFormattedTextField和JTextPane创建格式文本
  + 12.12.1 监听Document的变化
  + 12.12.2 使用JPasswordField
  + 12.12.3 使用JFormattedTextField
  + 12.12.4 使用JEditorPane
  + 12.12.5 使用JTextPane
+ 12.13 本章小结
+ 本章练习

### 第13章 MySQL数据库与JDBC编程
+ 13.1 JDBC基础
  + 13.1.1 JDBC简介
  + 13.1.2 JDBC驱动程序
+ 13.2 SQL语法
  + 13.2.1 安装数据库
  + 13.2.2 关系数据库基本概念和MySQL基本命令
  + 13.2.3 SQL语句基础
  + 13.2.4 DDL语句
  + 13.2.5 数据库约束
  + 13.2.6 索引
  + 13.2.7 视图
  + 13.2.8 DML语句语法
  + 13.2.9 单表查询
  + 13.2.10 数据库函数
  + 13.2.11 分组和组函数
  + 13.2.12 多表连接查询
  + 13.2.13 子查询
  + 13.2.14 集合运算
+ 13.3 JDBC的典型用法
  + 13.3.1 JDBC 4.2常用接口和类简介
  + 13.3.2 JDBC编程步骤
    + 学生提问：前面给出的仅仅是MySQL和Oracle 两种数据库的驱动，我看不出驱动类字符串有什么规律啊。如果我希望使用其他据库，那怎么找到其他数据库的驱动类呢?
+ 13.4 执行SQL语句的方式
  + 13.4.1 使用Java 8新增的executeLargeUpdate方法执行DDL和DML语句
  + 13.4.2 使用execute方法执行SQL语句
  + 13.4.3 使用PreparedStatement执行SQL语句
  + 13.4.4 使用CallableStatement调用存储过程
+ 13.5 管理结果集
  + 13.5.1 可滚动、可更新的结果集
  + 13.5.2 处理Blob类型数据
  + 13.5.3 使用ResultSetMetaData分析结果集
+ 13.6 Java 7的RowSet 1.1
  + 13.6.1 Java 7新增的RowSetFactory与RowSet
  + 13.6.2 离线RowSet
  + 13.6.3 离线RowSet的查询分页
+ 13.7 事务处理
  + 13.7.1 事务的概念和MySQL事务支持
  + 13.7.2 JDBC的事务支持
  + 13.7.3 Java 8增强的批量更新
+ 13.8 分析数据库信息
  + 13.8.1 使用DatabaseMetaData分析数据库信息
  + 13.8.2 使用系统表分析数据库信息
  + 13.8.3 选择合适的分析方式
+ 13.9 使用连接池管理连接
  + 13.9.1 DBCP数据源
  + 13.9.2 C3P0数据源
+ 13.10 本章小结
+ 本章练习

### 第14章 Annotation（注释）
+ 14.1 基本Annotation
  + 14.1.1 限定重写父类方法：＠Override
  + 14.1.2 标示已过时：＠Deprecated
  + 14.1.3 抑制编译器警告：＠SuppressWarnings
  + 14.1.4 Java 7的“堆污染”警告与＠SafeVarargs
  + 14.1.5 Java 8的函数式接口与＠FunctionalInterface
+ 14.2 JDK的元Annotation
  + 14.2.1 使用＠Retention
  + 14.2.2 使用＠Target
  + 14.2.3 使用＠Documented
  + 14.2.4 使用＠Inherited
+ 14.3 自定义Annotation
  + 14.3.1 定义Annotation
  + 14.3.2 提取Annotation信息
  + 14.3.3 使用Annotation的示例
  + 14.3.4 Java 8新增的重复注解
  + 14.3.5 Java 8新增的Type Annotation
+ 14.4 编译时处理Annotation
+ 14.5 本章小结

### 第15章 输入/输出
+ 15.1 File类
  + 15.1.1 访问文件和目录
  + 15.1.2 文件过滤器
+ 15.2 理解Java的IO流
  + 15.2.1 流的分类
  + 15.2.2 流的概念模型
+ 15.3 字节流和字符流
  + 15.3.1 InputStream和Reader
  + 15.3.2 OutputStream和Writer
+ 15.4 输入/输出流体系
  + 15.4.1 处理流的用法
  + 15.4.2 输入/输出流体系
  + 15.4.3 转换流
  + 学生提问：怎么没有把字符流转换成字节流的转换流呢?
  + 15.4.4 推回输入流
+ 15.5 重定向标准输入/输出
+ 15.6 Java虚拟机读写其他进程的数据
+ 15.7 RandomAccessFile
+ 15.8 对象序列化
  + 15.8.1 序列化的含义和意义
  + 15.8.2 使用对象流实现序列化
  + 15.8.3 对象引用的序列化
  + 15.8.4 自定义序列化
  + 15.8.5 另一种自定义序列化机制
  + 15.8.6 版本
+ 15.9 NIO
  + 15.9.1 Java新IO概述
  + 15.9.2 使用Buffer
  + 15.9.3 使用Channel
  + 15.9.4 字符集和Charset
    + 学生提问：二进制序列与字符之间如何对应呢?
  + 15.9.5 文件锁
+ 15.10 Java 7的NIO.2
  + 15.10.1 Path、Paths和Files核心API
  + 15.10.2 使用FileVisitor遍历文件和目录
  + 15.10.3 使用WatchService监控文件变化
  + 15.10.4 访问文件属性
+ 15.11 本章小结
+ 本章练习

### 第16章 多线程
+ 16.1 线程概述
  + 16.1.1 线程和进程
  + 16.1.2 多线程的优势
+ 16.2 线程的创建和启动
  + 16.2.1 继承Thread类创建线程类
  + 16.2.2 实现Runnable接口创建线程类
  + 16.2.3 使用Callable和Future创建线程
  + 16.2.4 创建线程的三种方式对比
+ 16.3 线程的生命周期
  + 16.3.1 新建和就绪状态
  + 16.3.2 运行和阻塞状态
  + 16.3.3 线程死亡
+ 16.4 控制线程
  + 16.4.1 join线程
  + 16.4.2 后台线程
  + 16.4.3 线程睡眠：sleep
  + 16.4.4 线程让步：yield
  + 16.4.5 改变线程优先级
+ 16.5 线程同步
  + 16.5.1 线程安全问题
  + 16.5.2 同步代码块
  + 16.5.3 同步方法
  + 16.5.4 释放同步监视器的锁定
  + 16.5.5 同步锁（Lock）
  + 16.5.6 死锁
+ 16.6 线程通信
  + 16.6.1 传统的线程通信
  + 16.6.2 使用Condition控制线程通信
  + 16.6.3 使用阻塞队列（BlockingQueue）控制线程通信
+ 16.7 线程组和未处理的异常
+ 16.8 线程池
  + 16.8.1 Java 8改进的线程池
  + 16.8.2 Java 8增强的ForkJoinPool
+ 16.9 线程相关类
  + 16.9.1 ThreadLocal类
  + 16.9.2 包装线程不安全的集合
  + 16.9.3 线程安全的集合类
+ 16.10 本章小结
+ 本章练习

### 第17章 网络编程
+ 17.1 网络编程的基础知识
  + 17.1.1 网络基础知识
  + 17.1.2 IP地址和端口号
+ 17.2 Java的基本网络支持
  + 17.2.1 使用InetAddress
  + 17.2.2 使用URLDecoder和URLEncoder
  + 17.2.3 URL、URLConnection和URLPermission
+ 17.3 基于TCP协议的网络编程
  + 17.3.1 TCP协议基础
  + 17.3.2 使用ServerSocket创建TCP服务器端
  + 17.3.3 使用Socket进行通信
  + 17.3.4 加入多线程
  + 17.3.5 记录用户信息
  + 17.3.6 半关闭的Socket
  + 17.3.7 使用NIO实现非阻塞Socket通信
  + 17.3.8 使用Java 7的AIO实现非阻塞通信
    + 学生提问：上面程序中好像没用到④⑤号代码的get（）方法的返回值，这两个地方不调用 get（）方法行吗?
+ 17.4 基于UDP协议的网络编程
  + 17.4.1 UDP协议基础
  + 17.4.2 使用DatagramSocket发送、接收数据
  + 17.4.3 使用MulticastSocket实现多点广播
+ 17.5 使用代理服务器
  + 17.5.1 直接使用Proxy创建连接
  + 17.5.2 使用ProxySelector自动选择代理服务器
+ 17.6 本章小结
+ 本章练习

### 第18章 类加载机制与反射
+ 18.1 类的加载、连接和初始化
  + 18.1.1 JVM和类
  + 18.1.2 类的加载
  + 18.1.3 类的连接
  + 18.1.4 类的初始化
  + 18.1.5 类初始化的时机
+ 18.2 类加载器
  + 18.2.1 类加载器简介
  + 18.2.2 类加载机制
  + 18.2.3 创建并使用自定义的类加载器
  + 18.2.4 URLClassLoader类
+ 18.3 通过反射查看类信息
  + 18.3.1 获得Class对象
  + 18.3.2 从Class中获取信息
  + 18.3.3 Java 8新增的方法参数反射
+ 18.4 使用反射生成并操作对象
  + 18.4.1 创建对象
  + 18.4.2 调用方法
  + 18.4.3 访问成员变量值
  + 18.4.4 操作数组
+ 18.5 使用反射生成JDK动态代理
  + 18.5.1 使用Proxy和InvocationHandler创建动态代理
  + 18.5.2 动态代理和AOP
+ 18.6 反射和泛型
  + 18.6.1 泛型和Class类
  + 18.6.2 使用反射来获取泛型信息
+ 18.7 本章小结
+ 本章练习
